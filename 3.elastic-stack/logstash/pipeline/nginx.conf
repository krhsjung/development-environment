input {
  beats {
    port => 5044
    ssl => true
    ssl_certificate => "/usr/share/logstash/certs/logstash/logstash.crt"
    ssl_key => "/usr/share/logstash/certs/logstash/logstash.key"
  }
}

filter {
    # ruby {
    #     code => 'puts "ðŸ“Œ ë¡œê·¸ í•„í„° í†µê³¼ ì¤‘: #{event.to_hash}"'
    # }
    if "access.log" in [log][file][path] {
        # ì•„ëž˜ì˜ mutate ì‚¬ìš©í•œ ê²ƒê³¼ ë™ì¼
        # ruby {
        #     code => '
        #         t = Time.at(event.get("@timestamp").to_f)
        #         event.set("[@metadata][target_index]", "nginx-access-" + t.strftime("%Y.%m.%d"))
        #     '
        # }
        mutate {
            add_field => { "[@metadata][target_index]" => "nginx-access-%{+YYYY.MM.dd}" }
        }
        grok {
            match => { "message" => "%{COMBINEDAPACHELOG}" }
        }
        date {
            match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
        }
    }

    if "error.log" in [log][file][path] {
        mutate {
            add_field => { "[@metadata][target_index]" => "nginx-error-%{+YYYY.MM.dd}" }
        }
        grok {
            match => { "message" => "\[%{HTTPDATE:timestamp}\] \[%{DATA:loglevel}\] %{GREEDYDATA:errormessage}" }
        }
    }

    mutate {
        remove_field => ["host", "agent", "ecs", "input", "[log][file][path]"]
    }
}

output {
    # ìˆ˜ì‹ í•œ ì´ë²¤íŠ¸ë¥¼ í‘œì¤€ ì¶œë ¥ìœ¼ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.
    stdout { codec => rubydebug }

    elasticsearch {
        hosts => ["https://elasticsearch:9200"]
        index => "%{[@metadata][target_index]}"
        user => "${ELASTIC_USER}"
        password => "${ELASTIC_PASSWORD}"
        ssl => true
        cacert => "/usr/share/logstash/certs/ca/ca.crt"
    }
}

